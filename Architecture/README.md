# Software Design
<img width="897" alt="Снимок экрана 2022-02-20 в 21 16 36" src="https://user-images.githubusercontent.com/57727520/154857576-e45b77dd-8dc4-4acc-beaf-042b18bf4a93.png">

* **App** – Точка входа в приложение. Использует другие модули для обработки запросов.

* **I/O** – Компонента, отвечающая за связь с внешним миром (в нашем случае с консолью. Пишет и читает из нее).


* **Substitution** – Модуль, отвечающий за подстановку переменных в строку <br>
  *Описание:* <br> Выполняем подстановку: для этого пройдемся по строчке запоминая, в каких самых внешних кавычках мы находимся (если находимся вообще).
  Ищем конструкции  `$varName`.<br>
  Если внешняя кавычка одинарная, то идем до следующей одинарной без подстановок, если двойная, то идем до следующей двойной и делаем подстановки (даже если `$varName` находится внутри одинарных кавычек). Если необходима подстановка переменной, которая отсутствует в окружении, подставляем пустую строку. Возвращаем измененную строку.


* **Parser** – Парсит строку и возвращает список команд для выполнения.<br>
  *Описание:* <br>
  Получаем на вход строку с выполненнными подстановками. Преобразует строку в список токенов: идет по строке и рассматривает каждый символ. Если встретили `|`,  `=` или `пробел` и при этом мы не в кавычках, то значит, что мы набрали новый токен - запоминаем его. Также если мы встретили пробел и мы не в кавычках, то пропускаем все следующие пробелы. Если мы встретили кавычку, то есть три варианта действий:
  - Если она является открывающей, то запоминаем ее тип, но к токену не добавляем. 
  - Если она другого типа, что та кавычка, которую мы запомнили, то просто добавляем ее к токену.  
  - Если она такого же типа, то мы вышли из кавычек. 
  
  Все остальные символы добавляем к токену. 
  Если после прохода по строке у нас осталась открывающая кавычка, то бросаем исключение.
  
  Дальше мы прохоидмся по списку токенов и раздаем им типы. Всего есть четыре типа:
  - COMMAND - команда
  - ARG - аргумент команды
  - PIPE - `|`
  - EQ - `=`

  Дальше идет стадия парсинга.  
  Разбиваем список токенов на команды с аргументами по PIPE. Каждую команду с аргументами конструируем в классы `Commands` (wc, cat, echo и др.). Возвращаем полученный список команд.

* **Environment** – Хранилище переменных из окружения. <br>
  *Описание:* <br>
  Хранит словарь со всеми переменными окружения.


* **Executor** – Элемент программы, который отвечает за запуск команд из очереди <br>
  *Описание:* <br>
  Принимает на вход очередь команд. Создает и поддерживает в корректном состоянии класс Context, в котором будут лежать:
    - Результат выполнения предыдущей команды
    - `Environment`, отвечающий за переменные окружения. <br><br>

  Последовательно выполняет команды, вызывая метод `execute(Context)`. После выполнения очередной команды присваивает ее результат в `Context`. <br><br>

  Если при выполнении команды произошла ошибка (код возврата команды не равен нулю), то возвращаем результат этой команды, прерывая последовательное выполнение.

* **FileManager** – Компонента, отвечающая за работу с файловой системой. Необходима для выполнения базовых операций с файлами.<br>
  *Описание:* <br>
  Список методов:
  
    - is_file - проверяет, существует ли файл
    - get_file_content - возвращает содержимое файла
    - get_directory_content - возвращает названия файлов в директории
    - get_current_directory - возвращает путь до текущей рабочей директории


* **Описание команд:**<br>
  Каждая команда - это класс с методом `execute`, который получает на вход текущий `Context` и возвращает результат выполнения: результирующую строку и код возврата.
    - cat — вывести на экран содержимое файла/файлов;<br>
      *Описание:* Проверяем, что все переданные аргументы являются путями до существующих файлов, используя **FileManager**. Обьединенияем их содержимое и возврщаем его с нулевым кодом возврата. Если хотя бы один из аргументов не является файлом, то возвращаем сообщение об ошибке и ненулевой код возврата. В случае отсутствия аргументов берем результат выполения предыдущей команды как аргумент. Если и результат преыдущей команды отсутствует, то возвращаем ошибку и ненулевой код возврата.
    
    - echo — вывести на экран свой аргумент (или аргументы);<br>
      *Описание:*<br>
      Игнорирует результат предыдущей команды. Если аргументов нет, возвращает пустую строку с нулевым кодом возврата, иначе возвращает все аргументы также с нулевым кодом возврата.<br><br>

    - wc — вывести количество строк, слов и байт в файле/файлах;<br>
      *Описание:*<br>
      Проверяем, что все переданные аргументы являются путями до существующих файлов, используя **FileManager**. Для каждого файла считаем кол-во строк, слов и байт, последовательно обьединяя результаты. Возвращаем общий результат с нулевым кодом возврата. Если аргументов не передано, то считаем кол-во строк, слов и байт для результата предыдущей команды. Если и преыдущего результата нет, то возвращаем сообщение об ошибке с ненулевым кодом возврата. <br><br>

    - pwd — вывести текущую директорию;<br>
      *Описание:*<br>  Выводит пользователю текущую директорию используя **FileManager**<br><br>

    - exit — выйти из интерпретатора. <br>
      *Описание:*<br> В глобальном флаге ``is_shell_terminated`` ставим `True`. Таким образом, обратываемый ввод станет последним, который выполнит интерпритатор. Возвращаем пустую строку и нулевой код возврата. <br><br>

    - eq — обновляет/добавляет значение переменной в **Environment**<br><br>

    - process — запускает внешнюю программу через ``subprocess``, передавая туда переменные окружения **Environment**<br><br>

    - grep – ищет заданный образец во входных данных и выводит строки, в которых он содержится <br>
      *Описание:*<br> Проходимся по каждой строке из входных данных (прочитали из файлов или получили выходные данные от другой команды через `context`) и ищем данный нам образец с помощью библиотеки `re`.<br>
      Команда также поддерживает следующие опции: 
      - `-i` ищет образец регистронезависимо. Для этого ставим флаг IGNORECASE, который будет использоваться при поиске
      - `-w` ищет выражение как слово, как если бы оно было окружено «non-word constituent character». Для этого соответствующе изменяем входной образец, чтобы он сопоставлялся только с отдельными словами
      - `-A append_number` вывести за строкой с совпадением еще `append_number` строк. Для этого объединяем два множества: в одном текущая строка, в которой нашли образец, во втором – `append_number` строк после текущей строки. В итоге нужная строка выводится только один раз.<br>

      Для того чтобы поддерживать опции было решено использовать сторонний фрейморк. В поиске такого фреймворка мы обратились на stackOverflow и подчерпнули для себя из рекомендации других разработчиков 3 фреймворка: `argparse`, `Docopt`, `Python Fire`.  
      `Docopt` основан на генерации правил парсинга по описанию интерфейса программы, который должен быть написан по устоявшимся соглашениям. Интересная библиотека, но удобство работы с ней остается под сомнением.
      `Python Fire` генерирует CLI интерфейс из любого pyhton-объекта. Крутая библиотека, но нужно много времени, чтобы с ней разобраться. К тому же создавать класс с методами занимает намного больше строчек кода.
      Выбор пал на `argparse` – модуль простой в использовании и имеет нужную функциональность - это были главные критерии при отборе. Также у нас был опыт работы с данным модулем.<br>
* **Поток исполнения**
  
  **App** получает строчку от пользователя с помощью **I/O**. Передает ее в класс **Substitution** для выполнения подстановок. Потом передает ее парсеру для получения списка команд. Дальше этот список команд передает **Executor** на исполнение, получает от него код возврата и результат исполнения и передает его **I/O** для вывода на экран. Если был выставлен флаг `is_shell_terminated`, то прекращаем выполнение программы, иначе ждем следующего ввода от пользователя.